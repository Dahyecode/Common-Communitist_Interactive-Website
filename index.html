<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plexus Effect - Word Pairs (YouTube Version)</title>
    <style>
        /* Í∏∞Î≥∏ Î¶¨ÏÖã */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            cursor: default;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* YouTube Background Container */
        .video-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Let clicks pass through to canvas */
            overflow: hidden;
            z-index: 1;
        }

        /* Iframe styling to cover screen without bars */
        .video-background iframe {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100vw;
            height: 56.25vw;
            /* 16:9 Aspect Ratio */
            min-height: 100vh;
            min-width: 177.77vh;
            /* 16:9 Aspect Ratio */
            transform: translate(-50%, -50%);
            border: none;
            opacity: 1.0;
        }

        /* Top Layer: Plexus Ìö®Í≥º Ï∫îÎ≤ÑÏä§ */
        #plexus-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        /* Sound Toggle Button */
        #sound-control {
            position: absolute;
            bottom: 30px;
            right: 30px;
            pointer-events: auto;
        }

        #unmute-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 24px;
            padding: 0;
            border-radius: 50%;
            cursor: pointer;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s, transform 0.2s;
        }

        #unmute-btn:hover {
            background: rgba(255, 255, 255, 0.7);
            color: black;
            transform: scale(1.1);
        }

        /* Input Area */
        #input-area {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 25px;
            border-radius: 50px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #comment-input {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 16px;
            padding: 5px;
            width: 250px;
            outline: none;
            transition: border-color 0.3s;
        }

        #comment-input:focus {
            border-bottom-color: #fff;
        }

        #comment-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #send-btn {
            background: white;
            color: black;
            border: none;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.2s, background 0.3s;
        }

        #send-btn:hover {
            transform: scale(1.05);
            background: #eee;
        }

        #send-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div id="sound-control">
            <button id="unmute-btn" title="Mute/Unmute">üîá</button>
        </div>
        <div id="input-area">
            <input type="text" id="comment-input" placeholder="Type a comment..." autocomplete="off">
            <button id="send-btn">Send</button>
        </div>
    </div>

    <!-- YouTube Iframe API Container -->
    <div class="video-background">
        <div id="player"></div>
    </div>

    <canvas id="plexus-canvas"></canvas>

    <script>
        /**
         * Configuration
         */
        const CONFIG = {
            particleCount: 100,
            connectDistance: 120,
            mouseRadius: 400,
            particleSpeed: 1.0,
            particleSizeMin: 12,
            particleSizeMax: 24,
            color: { r: 255, g: 255, b: 255 },
            // Paired texts: Top (Korean) and Bottom (English)
            texts: [
                { top: "Í∞à„ÖÇ*„Öã„Öã", bottom: "You f*** wh**.‚Äù*" },
                { top: "„Ñ±„ÖÖ„Ñ≤", bottom: "son of b****" },
                { top: "Í∫ºÏ†∏ Ïù¥ Í∏âÏãùÏ∂© ÏÉàÎÅºÏïº.", bottom: "f*** you **** kid" },
                { top: "Îãà Ïï†„ÖÅ „ÖÇ„Öà", bottom: "Your mother‚Äôs c***" },
                { top: "„ÖÇ„ÖÖ", bottom: "A**h***" },
                { top: "„ÖÖ„ÖÇ", bottom: "F***" },
                { top: "ÏçÖ*Ïù¥", bottom: "You f*** b****" },
                { top: "„ÖàÍπå", bottom: "F*** off" },
                { top: "‚Äã„Ñ¥„Ñ±„ÖÅ", bottom: "you motherf*****" },
                { top: "Í±∏Î†à*", bottom: "c***" },
                { top: "Ï∞Ω*", bottom: "b****" }
            ]
        };

        /**
         * Setup
         */
        const canvas = document.getElementById('plexus-canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();


        /**
         * YouTube Player Global API
         */
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        var player;
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                videoId: 'Fji4tImT-QU',
                playerVars: {
                    'autoplay': 1,
                    'controls': 0,
                    'rel': 0,
                    'showinfo': 0,
                    'modestbranding': 1,
                    'loop': 1,
                    'playlist': 'Fji4tImT-QU',
                    'mute': 1,
                    'playsinline': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onError': onPlayerError
                }
            });
        }

        function onPlayerReady(event) {
            event.target.playVideo();
            event.target.mute();
        }

        function onPlayerStateChange(event) {
            // Manual Loop: When video ends (state 0), play again
            if (event.data === YT.PlayerState.ENDED) {
                player.playVideo();
            }
        }

        function onPlayerError(event) {
            console.error("YouTube Player Error:", event.data);
            // Don't show annoying alerts to the background, just log it. 
            // If it fails on file://, the user might need a local server.
            console.log("If the video doesn't play, please try opening this file through a local server (e.g. Live Server).");
        }

        // Sound Control Logic
        const unmuteBtn = document.getElementById('unmute-btn');
        unmuteBtn.addEventListener('click', () => {
            if (!player) return;

            if (player.isMuted()) {
                player.unMute();
                unmuteBtn.textContent = 'üîä';
            } else {
                player.mute();
                unmuteBtn.textContent = 'üîá';
            }
        });


        /**
         * Mouse State
         */
        const mouse = { x: null, y: null };
        window.addEventListener('mousemove', e => { mouse.x = e.x; mouse.y = e.y; });
        window.addEventListener('mouseout', () => { mouse.x = null; mouse.y = null; });

        /**
         * Particle Class
         */
        class Particle {
            constructor(customText = null, startPos = null) {
                this.customText = customText;
                this.reset(true, startPos);
            }

            reset(isFirst = false, startPos = null) {
                // 1. ÏúÑÏπò ÏÑ§Ï†ï (Random only, due to YouTube iframe CORS)
                if (isFirst && startPos) {
                    this.x = startPos.x;
                    this.y = startPos.y;
                } else {
                    this.x = Math.random() * width;
                    this.y = Math.random() * height;
                }

                // 2. ÏÜçÎèÑ
                this.vx = (Math.random() - 0.5) * CONFIG.particleSpeed;
                this.vy = (Math.random() - 0.5) * CONFIG.particleSpeed;

                // 3. ÌÖçÏä§Ìä∏ Ìï†Îãπ
                if (this.customText) {
                    this.textObj = { top: this.customText, bottom: "" };
                } else {
                    this.textObj = CONFIG.texts[Math.floor(Math.random() * CONFIG.texts.length)];
                }

                this.size = Math.random() * (CONFIG.particleSizeMax - CONFIG.particleSizeMin) + CONFIG.particleSizeMin;

                // ÏàòÎ™Ö
                this.life = 1.0;
                this.decay = Math.random() * 0.01 + 0.005;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;

                // ÎßàÏö∞Ïä§ Ïù∏Î†•
                if (mouse.x != null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < CONFIG.mouseRadius) {
                        const force = (CONFIG.mouseRadius - distance) / CONFIG.mouseRadius;
                        const pullStrength = force * 0.02;
                        this.vx += dx * pullStrength;
                        this.vy += dy * pullStrength;
                    }
                }

                this.vx *= 0.95;
                this.vy *= 0.95;

                // ÌôîÎ©¥ Î∞ñ or ÏàòÎ™Ö Ï¢ÖÎ£å Ïãú Î¶¨ÏÖã
                if (this.life <= 0 ||
                    this.x < -100 || this.x > width + 100 ||
                    this.y < -50 || this.y > height + 50) {
                    this.reset();
                }
            }

            draw() {
                ctx.save();
                ctx.font = `bold ${this.size}px 'Segoe UI', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Glitch / Chromatic Aberration Effect settings
                // Random jitter for "nervous" look
                const jitterX = (Math.random() - 0.5) * 1.5;
                const jitterY = (Math.random() - 0.5) * 1.5;

                // Occasional "heavy" glitch
                const isGlitching = Math.random() < 0.03; // 3% chance
                const glitchOffset = isGlitching ? (Math.random() - 0.5) * 10 : 0;

                // Draw Red Channel (offset right)
                ctx.fillStyle = `rgba(255, 0, 70, ${this.life * 0.7})`;
                this.drawText(this.x + 2 + jitterX + glitchOffset, this.y + jitterY);

                // Draw Cyan Channel (offset left)
                ctx.fillStyle = `rgba(0, 255, 255, ${this.life * 0.7})`;
                this.drawText(this.x - 2 + jitterX - glitchOffset, this.y + jitterY);

                // Draw Main White Text
                ctx.fillStyle = `rgba(${CONFIG.color.r}, ${CONFIG.color.g}, ${CONFIG.color.b}, ${this.life})`;
                this.drawText(this.x + jitterX, this.y + jitterY);

                ctx.restore();
            }

            // Helper to draw the text (handles single or double lines)
            drawText(x, y) {
                if (this.textObj.bottom) {
                    const spacing = this.size * 1.0;
                    ctx.fillText(this.textObj.top, x, y - spacing / 2);
                    // Slightly smaller font for English translation
                    ctx.save();
                    ctx.font = `bold ${this.size * 0.7}px 'Segoe UI', sans-serif`;
                    ctx.fillText(this.textObj.bottom, x, y + spacing / 2);
                    ctx.restore();
                } else {
                    ctx.fillText(this.textObj.top, x, y);
                }
            }
        }

        let particles = [];
        // Ï¥àÍ∏∞ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
        for (let i = 0; i < CONFIG.particleCount; i++) {
            particles.push(new Particle());
        }

        // Comment Submission Logic (UI)
        const commentInput = document.getElementById('comment-input');
        const sendBtn = document.getElementById('send-btn');

        function addCommentParticle(text) {
            if (!text.trim()) return;
            const startPos = { x: width / 2, y: height / 2 };
            const p = new Particle(text, startPos);
            p.vx = (Math.random() - 0.5) * 3;
            p.vy = (Math.random() - 0.5) * 3;
            p.life = 1.0;
            particles.push(p);
        }

        sendBtn.addEventListener('click', () => {
            const text = commentInput.value;
            if (text) {
                addCommentParticle(text);
                commentInput.value = '';
                commentInput.focus();
            }
        });

        commentInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendBtn.click();
            }
        });


        /**
         * Main Loop
         */
        function animate() {
            requestAnimationFrame(animate);

            ctx.clearRect(0, 0, width, height);

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
                particles[i].draw();
            }

            connectParticles();
        }

        function connectParticles() {
            for (let a = 0; a < particles.length; a++) {
                for (let b = a + 1; b < particles.length; b++) {
                    let dx = particles[a].x - particles[b].x;
                    let dy = particles[a].y - particles[b].y;
                    let distSq = dx * dx + dy * dy;

                    let range = CONFIG.connectDistance;
                    if (mouse.x != null) {
                        const distToMouse = Math.hypot(particles[a].x - mouse.x, particles[a].y - mouse.y);
                        if (distToMouse < CONFIG.mouseRadius) {
                            range = CONFIG.connectDistance * 1.5;
                        }
                    }

                    if (distSq < range * range) {
                        const dist = Math.sqrt(distSq);
                        const alpha = (1 - dist / range) * Math.min(particles[a].life, particles[b].life);

                        ctx.beginPath();
                        ctx.moveTo(particles[a].x, particles[a].y);
                        ctx.lineTo(particles[b].x, particles[b].y);
                        ctx.lineWidth = 1.0;
                        ctx.strokeStyle = `rgba(${CONFIG.color.r}, ${CONFIG.color.g}, ${CONFIG.color.b}, ${alpha})`;
                        ctx.stroke();
                    }
                }
            }
        }

        animate();

    </script>
</body>

</html>